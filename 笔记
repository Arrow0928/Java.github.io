@Slf4j     /*控制台输出日志  log 日志*/

 dto(Data Transfer Object即数据传输对象) 封装不止包含实体的数据

 对象拷贝（除"record"属性)BeanUtils.copyProperties(pageInfo,dishDtoPage,"records");
 
 XXXDto 继承实体，用来封装实体不存在的属性。


redis 基于内存的数据库

redis Springboot 默认配置RedisTemplate 直接 @Autowired 

用户禁止cookie后，如何继续使用session


    (1)如果用户禁止cookie，服务器仍会将sessionId以cookie的方式发送给浏览器，但是，浏览器不再保存这个cookie(即sessionId)了。

    (2)如果想继续使用session，需要采取其他方式来实现sessionId的跟踪。

        可以使用url重写来实现sessionId的跟踪。

    (3)url重写

        a,什么是URL重写



redis 实现共享session  https://www.bilibili.com/video/BV1cr4y1671t?p=32
   用每建立一个session 都会在用户的cookie存入一个sessionid
   token为key 保存用户信息 返回token到前端，保存到前端浏览器，登录凭证，以后每次axios请求携带token
   token 登录密码校验-》生成token,登录外的其他接口访问，token校验
   每个线程内需要保存类似于全局变量的信息（例如在拦截器中获取的用户信息），可以让不同方法直接使用，避免参数传递的麻烦却不想被多线程共享（因为不同线程获取到的用户信息不一样）。
   保存登录的用户信息，1. String 结构的json  直观  2.hash结构  将对象的每个字段独立存储，可以对单个字段作crud,并且内存占用小
例如，用 ThreadLocal 保存一些业务内容（用户权限信息、从用户系统获取到的用户名、用户ID 等），这些信息在同一个线程内相同，但是不同的线程使用的业务内容是不相同的。

在线程生命周期内，都通过这个静态 ThreadLocal 实例的 get() 方法取得自己 set 过的那个对象，避免了将这个对象（如 user 对象）作为参数传递的麻烦。

比如说我们是一个用户系统，那么当一个请求进来的时候，一个线程会负责执行这个请求，然后这个请求就会依次调用service-1()、service-2()、service-3()、service-4()，这4个方法可能是分布在不同的类中的。这个例子和存储session有些像。

 redis 验证码
    拦截器 （解决访问非登录页面刷新问题）
      第一层拦截一切刷新有效期1.获取token 2.查询redis的用户3.保存到threadlocal 4.刷新token有效期5.放行
      第二层拦截需要登录的路径 1.查询threadlocal的用户 1.不存在则拦截
自己创建的类里，不能对对象进行依赖注入


