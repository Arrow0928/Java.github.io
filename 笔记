@Slf4j     /*控制台输出日志  log 日志*/

 dto(Data Transfer Object即数据传输对象) 封装不止包含实体的数据

 对象拷贝（除"record"属性)BeanUtils.copyProperties(pageInfo,dishDtoPage,"records");
 
 XXXDto 继承实体，用来封装实体不存在的属性。


redis 基于内存的数据库

redis Springboot 默认配置RedisTemplate 直接 @Autowired 

用户禁止cookie后，如何继续使用session


    (1)如果用户禁止cookie，服务器仍会将sessionId以cookie的方式发送给浏览器，但是，浏览器不再保存这个cookie(即sessionId)了。

    (2)如果想继续使用session，需要采取其他方式来实现sessionId的跟踪。

        可以使用url重写来实现sessionId的跟踪。

    (3)url重写

        a,什么是URL重写



redis 实现共享session  https://www.bilibili.com/video/BV1cr4y1671t?p=32
   用每建立一个session 都会在用户的cookie存入一个sessionid
   token为key 保存用户信息 返回token到前端，保存到前端浏览器，登录凭证，以后每次axios请求携带token
   token 登录密码校验-》生成token,登录外的其他接口访问，token校验
   每个线程内需要保存类似于全局变量的信息（例如在拦截器中获取的用户信息），可以让不同方法直接使用，避免参数传递的麻烦却不想被多线程共享（因为不同线程获取到的用户信息不一样）。
   保存登录的用户信息，1. String 结构的json  直观  2.hash结构  将对象的每个字段独立存储，可以对单个字段作crud,并且内存占用小
例如，用 ThreadLocal 保存一些业务内容（用户权限信息、从用户系统获取到的用户名、用户ID 等），这些信息在同一个线程内相同，但是不同的线程使用的业务内容是不相同的。

在线程生命周期内，都通过这个静态 ThreadLocal 实例的 get() 方法取得自己 set 过的那个对象，避免了将这个对象（如 user 对象）作为参数传递的麻烦。

比如说我们是一个用户系统，那么当一个请求进来的时候，一个线程会负责执行这个请求，然后这个请求就会依次调用service-1()、service-2()、service-3()、service-4()，这4个方法可能是分布在不同的类中的。这个例子和存储session有些像。

 redis 验证码
    拦截器 （解决访问非登录页面刷新问题）
      第一层拦截一切刷新有效期1.获取token 2.查询redis的用户3.保存到threadlocal 4.刷新token有效期5.放行
      第二层拦截需要登录的路径 1.查询threadlocal的用户 1.不存在则拦截
      （配置在mvcconfig自定义)（AOP) (按添加顺序执行）
      aop:   aop日志处理 https://www.jb51.net/article/225483.htm
      @Before("log()")
  public void doBefore(JoinPoint joinPoint){
    System.out.println("在进入controller之前处理流-------------");
 }
   @After("log()")
  public void doAfter(){
    System.out.println("在进入controller之后处理流-------------");
  }
  //在切入点return内容之后切入内容（可以用来对处理返回值做一些加工处理）
  @AfterReturning(returning = "result",pointcut="log()")
  public void doAfterReturning(Object result){
    logger.info("Return ------ {}",result );
   }
   在进入controller之前处理流-------------
  2021-08-15 15:19:43.923  INFO 9644 --- [nio-8080-exec-1] com.blog.AspectAop.LogAspect             : RequestData------RequestData{url='http://localhost:8080/', ipAddr='0:0:0:0:0:0:0:1', classMethod='com.blog.Controller.IndexController,index', args=[]}
  2021-08-15 15:19:43.932  INFO 9644 --- [nio-8080-exec-1] com.blog.AspectAop.LogAspect             : Return ------ index
   在进入controller之后处理流-------------
      
      
      缓存更新策略的最佳实践方案:
1.低一致性需求（不怎么改变，店铺类型）:使用Redis自带的内存淘汰机制
2.高一致性需求（店铺详情）:主动更新，并以超时剔除作为兜底方案
◆读操作:
●缓存命中则直接返回
●缓存未命中则查询数据库，并写入缓存，设定超时时间
◆写操作:
●先写数据库，然后再删除缓存
●要确保数据库与缓存操作的原子性

      
  操作缓存   删除缓存还是更新   
          更新缓存：没次更新数据库都更新缓存，无效写操作比较多
      用  删除缓存：更新数据库时让缓存失效，查询时更新缓存
      先操作数据库，后删除缓存  https://www.bilibili.com/video/BV1cr4y1671t?p=38
      redis失效->查询缓存未命中查数据库->
                                        更新数据库->删缓存（更新数据库时间长，发生概率小）
                                                                ->写入缓存      
      先删缓存都操作数据库
             1.删除缓存
                          ->2.查询缓存，未命中，查询数据库->3.写入缓存（快）
                                                                              ->更新数据库（时间长概率大）
                                                                              
    缓存穿透
      缓存穿透是指客户端请求的数据在缓存中和数据库中都不存在，这样缓存永远不会生效,这些请求都会打到数据库。（如果一堆恶意请求可能会搞垮数据库）

自己创建的类里，不能对对象进行依赖注入


